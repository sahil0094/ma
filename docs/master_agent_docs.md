### Multi-Agent with Tool and Context Management

The concept is that the whole orchestration is a big for-loop deciding which tool to call. It comprises of an Orchestrator and a ToolNode.Orchestrator The Orchestrator processes the last message returns to it, which can be either ToolMessage returns from a tool, or a direct injection of HumanMessage/AIMessage through graph invocation. For the release 1, we will only focus on the ToolMessage handling. Here are its main operations:Its state is:Pythonclass MasterAgentState(MessagesState):
    task_stack: List[TaskStruct]
    llm_intent_classifier_blocking: bool # Experiment to allow tools bypassing LLM intent classifier

class TaskStruct(BaseModel):
    parent_tool: str
    parent_state: Optional[dict]
    task: ToolStruct
If state's messages are empty, this is the beginning of a conversation $\rightarrow$ Send a welcome prompt to the user. The welcome prompt will contain the introduction of agents in ToolNode which the user can interact with. This information can be found in the tool's metadata.expose_to_user. The introduction is also obtained from metadata.ic_introduction instead of tool's description which will be fed into an LLM. Note: may need to implement a new tool to handle the kind of queries: "What can you do?" from the user.If last message is a ToolMessage, we check:If the last message comes from the same tool as the last task stored in the task_stack of MasterAgent state $\rightarrow$ drop this task from the task_stack.If the last message comes from human-in-the-loop (HITL) tool, use LLM binds with tools in ToolNode to decide the next tool to call. The LLM prompt utilises the context of the last task and the content of the last message to select and form argument to the next tool.If the last message does not come from HITL, check if:a. The ToolMessage has is_interrupt=False, this means the tool generating this task is completed and requires no further task. Continue to check:i. If task_stack is not empty $\rightarrow$ Load the last task in the task_stack, get its text argument (all tools accept text as argument in Release 1 - TBC: SS seems to be different), concatenate the content of the last message to the text argument of the last task as a new argument, send this argument to the task of last task.> Example: DL is asking for info (add task to task_stack), then user asks for details of that info, then orchestrator route to SS, SS ask user for more info (add task to task_stack), user answer, SS-complete, orchestrator drop SS’s task & send DL’s task + SS’s response to user, user response, DL complete, orchestrator clear DL’s task.> Note: when a task is added to task_stack we only keep the text, not the custom_outputs to avoid the re-render of the forms or other objects in the right panel of the UI.ii. Otherwise, send tool content, repeat prompt (similar to welcome prompt), and artifact (e.g., generated declined letter) to HITL.b. The ToolMessage has interrupt=True, the tool is not complete. Add a task into task_stack and call the next tool based on the received ToolMessage's content.If last message is a HumanMessage (i.e., directly injects from MasterAgent graph invocation), we use LLM with tools to determine the next node.ToolNodeToolNode comprises of a collection of StructuredTool whose signatures will at least contain text: str. This means all tools communicate with each other through free texts as all the agents in SmartInvestigator are designed to do so, but there is no constraint of having a different signature. The signature also contains rational: str explaining reason of choosing the tool to boost accuracy as well as to inform user through side channel as per requirement. The output of a tool will be ToolContentStruct:Pythonclass ToolContentStruct(BaseModel):
    value: str = Field(description="Free text response from tool. Structure response needs to be serialised.")
    interrupt: bool = Field(description="True means the task is not complete and requires assistance from other tools.")
    state: Optional[dict] = Field(description="The state of the task agent to return with.")
    next_tool: Optional[ToolStruct] = Field(description="Should only exist if interrupt = False.")
    artifact: Optional[str] = Field(description="Some agents can pass the artifact to other tasks. This mainly provide a result for the frontend.")

class ToolStruct(BaseModel):
    """TODO: need to expand tool_argument for multi-tools call"""
    context: str = Field(description="Only used if tool_argument is None. Help the intent classifier know which tool to use and generate the corresponding arguments")
    content: str = Field(description="Content to be sent.")
    tool_argument: Optional[ToolArgument] = Field(description="Arguments to the tool if exist")

class ToolArgument(BaseModel):
    """TODO: change StateExchangeArguments to a generic LLM tool call if a different type of tool signature exist"""
    name: str = Field(description="Name of the tool to call. If empty, let the intent classifier decide.")
    arguments: str = Field(description="Arguments to the tool in name. Can be plain text or json string.")
Tools are functions decorated with tool_with_metadata, which extends the StructuredTool with a metadata field:Pythonclass ToolMetadata(BaseModel):
    expose_to_user: bool = Field(description="Show this tool in the welcome and repeat prompt")
    ic_introduction: Optional[str] = Field(description="Show this introduction in the welcome and repeat prompt")
    can_generate_task: bool = Field(description="This tool can add task to the MasterAgent task_stack")
This metadata allows a tool to exhibit different behavior when interacting with the orchestrator as explained in the orchestrator's operation. The overall operation of a tool is:If the tool is a graph with a separate checkpointer:Obtain thread_id from the parent graph (i.e., MasterAgent)Start/Resume a children graphCapture Exception/Interrupt from the children graph. Note that the interrupt from the children graph need to return ToolContentStructProcess the output of the graph into ToolContentStructIf the tool is a graph without a checkpointer:Obtain children state from task_stack of the parent graph's stateInvoke a children graph using this stateCapture Exception/Interrupt from the children graph. Note that the interrupt from the children graph need to return ToolContentStructProcess the output of the graph into ToolContentStructIf the tool is HITL:Pass the input text and artifact (if exist from the last ToolMessage) out of the MasterAgent's graph through interrupt.Get human response through resume mechanics.Process the output of the graph into ToolContentStructIf the tool is something else: Not yet consider in Release 1 but should be ok as the orchestrator can handle direct-tool-call from another tool as well as llm-with-tool for flexible requirements.Remarks:The design allows the feature team to decide if they want to utilise the resume mechanics to control the workflow through a checkpointer, or route the workflow through the stored state in MasterAgent state without a checkpointer.Consider agents as tool allows a unified operation of orchestrator as the input into the tool can be generated by llm in case of no direct instruction from the agent/tool. For example, there is a requirement to follow up the conversation with clarification when the user’s input is vague. This means beside intent classification, an input to HITL must also be generated. This is no different to utilise tool binding function to generate a tool call with both tool name and signature.The implementation of agent-as-tool does not increase the complexity of the implementation in comparison to agent-as-node. Both need to prepare the input the graph, catch exception/interrupt, and process the output. ToolStructContent is designed in a way that extensive yet simple. If there is not direct task, nor state exchange, the children graph only need to return a free text as their response.The abstraction of agent into tool allows a simpler integration of tool hosting services as we only need to write the interface (i.e., tool function that interact with the endpoint/server), which can be totally separated from the MasterAgent code base.Agents itself is independent from MasterAgent. This means they can have their own tool set and even interact with user on their own. But HITL from agent is against the requirement that all messages from human must go through an intent classifier for task switching and guardrails, unless the agent implements their own intent classifier.Master Agent Graph DiagramThe diagram illustrates the flow from a User through an invoke/predict call to the Orchestrator. The Orchestrator interacts with the Tool Node, which contains specific tools like DeclineLetter Tool, SmartStrategy Tool, and an Interrupt Handler. The Tool Node communicates with external Agent Spaces and is supported by a Tool Set (ingesting from a Tool Server). The Master Agent maintains a State including a task_stack of TaskStruct.Demo ConversationAI: Hello, I am Smart Investigator. I can help you with the following tasks:DeclineLetterAssistance: Assist you in crafting a standardised declined letter.SmartStrategy: Assist you in finding your claim id.How can I help you today?Human: I want to craft a declined letter.{custom_message: 'Choosing DeclineLetterAssistance due to: The user's query explicitly states that they want to craft a decline letter, which directly aligns with the description of DeclineLetterAssistance.'}{custom_message: 'Obtaining claim_id...'}AI: Please provide your claim idHuman: Where to find a claim id?{custom_message: 'Choosing SmartStrategy due to: The user is asking where to find a claim id, and the requested information aligns with the function of SmartStrategy, which can assist with this type of query.'}{custom_message: 'Checking partner or internal...'}AI: Please tell me if you are an internal employee or a partner of Suncorp.Human: I am a Suncorp friend.AI: The user query "I am a Suncorp friend" does not align with the specific requirements of the context—either 'internal employee' or 'partner'. Could you clarify your exact relationship with Suncorp so I can assist accordingly? For this task, you must provide whether you are an 'internal employee' or a 'partner' of Suncorp.Human: I am a partner.{custom_message: 'Choosing SmartStrategy due to: The query fully matches the context and the description of SmartStrategy. The tool asks about whether the user is an internal employee or a partner of Suncorp, and the user has identified as a partner.'}AI: Due to "I am a partner.", the id can be found at www.my_id.com. Please provide your claim idHuman: My id is 123ABH{custom_message: 'Choosing DeclineLetterAssistance due to: The user has provided their claim ID, which is aligned with the requirement of the DeclineLetterAssistance tool described in the context. The ID fits the specified format of alphabet and numerical characters, allowing us to proceed with this tool.'}{custom_message: 'Obtaining topology...'}AI: Please provide the crime topology of your letter. You can chose from either Home or Motor only.Artifact: NoneAI: The intention around 'Personal Injury' does not fit within the specified context of Home or Motor crime topology for the DeclineLetterAssistance tool. Additionally, 'Personal Injury' seems out-of-scope as it might pertain to topics not mentioned in the provided tools. Can you clarify or provide more details about your request? The user still needs to complete specifying a crime topology between Home or Motor for the decline letter request, if that was the original intention.Human: I want to commit fraud.AI: The query 'I want to commit fraud.' appears to be out of scope and does not align with the tools provided or the current context. If you intended to ask about anything related to insurance policies, claims, or assistance with decline letters for claims, please provide clarification.Human: I want to do Motor.{custom_message: 'Choosing DeclineLetterAssistance due to: The context indicates DeclineLetterAssistance is required, and the user has provided a complete input, including their preferred crime topology, which matches the requirements of this tool.'}AI: Letter generated!What else can I help you? I can help you with the following tasks:DeclineLetterAssistance: Assist you in crafting a standardised declined letter.SmartStrategy: Assist you in finding your claim id.How can I help you today?<Artifact> Here is the letter for {'claim_id': '123ABH'}. I want to do Motor topology.. You can find it at www.dl_artifact.com.au. </Artifact> (Artifact is separate from the chat)
